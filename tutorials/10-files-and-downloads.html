<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Tutorial 10: Files and Downloads - CurlDotNet Documentation. Pure .NET implementation of curl for C#.">
    <meta name="keywords" content="curl, .NET, C#, HTTP, REST API, NuGet, CurlDotNet">
    <meta name="author" content="Jacob Mellor, IronSoftware">
    <title>Tutorial 10: Files and Downloads | CurlDotNet Documentation</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.2.0/github-markdown.min.css">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f5f5f5;
        }

        /* Beautiful Header - matches homepage */
        .site-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px 20px;
            text-align: center;
        }
        .site-header h1 {
            font-size: 2.5em;
            margin-bottom: 8px;
        }
        .site-header h1 a {
            color: white;
            text-decoration: none;
        }
        .site-header h1 a:hover {
            text-decoration: underline;
        }
        .site-header .tagline {
            font-size: 1.1em;
            opacity: 0.9;
            margin-bottom: 15px;
        }
        .header-nav {
            margin-top: 15px;
        }
        .header-nav a {
            color: white;
            text-decoration: none;
            margin: 0 12px;
            padding: 8px 16px;
            border-radius: 20px;
            background: rgba(255,255,255,0.15);
            display: inline-block;
            font-size: 0.95em;
            transition: background 0.2s;
        }
        .header-nav a:hover {
            background: rgba(255,255,255,0.3);
        }

        /* Section Title Bar */
        .section-bar {
            background: #2d3748;
            color: white;
            padding: 20px;
            text-align: center;
        }
        .section-bar .section-name {
            font-size: 0.9em;
            opacity: 0.7;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .section-bar h2 {
            font-size: 1.8em;
            margin-top: 5px;
        }

        /* Breadcrumbs */
        .breadcrumbs {
            background: #e2e8f0;
            padding: 12px 20px;
            font-size: 0.9em;
        }
        .breadcrumbs-inner {
            max-width: 900px;
            margin: 0 auto;
        }
        .breadcrumbs a {
            color: #667eea;
            text-decoration: none;
        }
        .breadcrumbs a:hover {
            text-decoration: underline;
        }
        .bc-sep {
            color: #718096;
            margin: 0 6px;
        }

        /* Main Content */
        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 30px 20px;
        }
        .content-card {
            background: white;
            padding: 40px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .markdown-body { font-size: 16px; }
        .markdown-body pre {
            background: #f6f8fa;
            padding: 16px;
            overflow: auto;
            border-radius: 6px;
        }
        .markdown-body code {
            background: #f6f8fa;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.9em;
        }
        .markdown-body pre code {
            background: none;
            padding: 0;
        }
        .markdown-body a { color: #667eea; }
        .markdown-body h1, .markdown-body h2, .markdown-body h3 {
            margin-top: 24px;
            margin-bottom: 16px;
            border-bottom: 1px solid #e1e4e8;
            padding-bottom: 8px;
        }
        .markdown-body h1:first-child { margin-top: 0; }

        /* Footer */
        .site-footer {
            background: #2d3748;
            color: white;
            padding: 40px 20px;
            text-align: center;
            margin-top: 40px;
        }
        .footer-links {
            margin-bottom: 20px;
        }
        .footer-links a {
            color: #68d391;
            text-decoration: none;
            margin: 0 15px;
            font-size: 1em;
        }
        .footer-links a:hover {
            text-decoration: underline;
        }
        .sponsor-info {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #4a5568;
        }
        .sponsor-info a {
            color: #68d391;
            text-decoration: none;
        }
        .sponsor-info a:hover {
            text-decoration: underline;
        }
        .author-info {
            margin-top: 10px;
            font-size: 0.95em;
            opacity: 0.9;
        }
    </style>
</head>
<body>
    <header class="site-header">
        <h1><a href="/">üì¶ CurlDotNet</a></h1>
        <p class="tagline">Pure .NET implementation of curl - Paste any curl command into C#</p>
        <nav class="header-nav">
            <a href="/getting-started/">Get Started</a>
            <a href="/tutorials/">Tutorials</a>
            <a href="/cookbook/">Cookbook</a>
            <a href="/api/">API Reference</a>
            <a href="https://github.com/jacob-mellor/curl-dot-net">GitHub</a>
            <a href="https://www.nuget.org/packages/CurlDotNet/">NuGet</a>
        </nav>
    </header>

    <div class="section-bar">
        <div class="section-name">Tutorials</div>
        <h2>Tutorial 10: Files and Downloads</h2>
    </div>

    <nav class="breadcrumbs">
        <div class="breadcrumbs-inner">
            <a href="/">Home</a> <span class="bc-sep">‚Ä∫</span> <a href="/tutorials/">Tutorials</a>
        </div>
    </nav>

    <main class="container">
        <article class="content-card markdown-body">
<h1>Tutorial 10: Files and Downloads</h1>
<p>Learn how to download files, upload documents, and handle binary data with CurlDotNet.</p>
<h2>Downloading Files</h2>
<h3>Simple File Download</h3>
<pre><code class="language-csharp">var curl = new Curl();

// Download to file
await curl.DownloadFileAsync(
    &quot;https://example.com/document.pdf&quot;,
    &quot;/path/to/save/document.pdf&quot;
);

Console.WriteLine(&quot;File downloaded successfully!&quot;);
</code></pre>
<h3>Download with Progress</h3>
<pre><code class="language-csharp">public async Task DownloadWithProgress(string url, string filePath)
{
    var curl = new Curl();

    // Set up progress tracking
    curl.OnProgress = (downloaded, total) =&gt;
    {
        if (total &gt; 0)
        {
            var percentage = (downloaded * 100.0) / total;
            Console.Write($&quot;\rDownloading: {percentage:F1}% ({downloaded}/{total} bytes)&quot;);
        }
    };

    await curl.DownloadFileAsync(url, filePath);
    Console.WriteLine(&quot;\nDownload complete!&quot;);
}
</code></pre>
<h3>Download to Memory</h3>
<pre><code class="language-csharp">// For small files - load into memory
var curl = new Curl();
var bytes = await curl.GetBytesAsync(&quot;https://example.com/image.jpg&quot;);

// Process in memory
using var stream = new MemoryStream(bytes);
using var image = Image.FromStream(stream);
Console.WriteLine($&quot;Image size: {image.Width}x{image.Height}&quot;);

// Save if needed
File.WriteAllBytes(&quot;image.jpg&quot;, bytes);
</code></pre>
<h2>Uploading Files</h2>
<h3>Simple File Upload</h3>
<pre><code class="language-csharp">var curl = new Curl();

// Upload a single file
var result = await curl.UploadFileAsync(
    &quot;https://api.example.com/upload&quot;,
    &quot;/path/to/file.pdf&quot;,
    &quot;file&quot;  // Form field name
);

if (result.IsSuccess)
{
    Console.WriteLine(&quot;Upload successful!&quot;);
    var response = JsonSerializer.Deserialize&lt;UploadResponse&gt;(result.Data);
    Console.WriteLine($&quot;File ID: {response.FileId}&quot;);
}
</code></pre>
<h3>Multi-Part Form Upload</h3>
<pre><code class="language-csharp">// Upload file with additional form data
var additionalData = new Dictionary&lt;string, string&gt;
{
    [&quot;description&quot;] = &quot;Monthly report&quot;,
    [&quot;category&quot;] = &quot;reports&quot;,
    [&quot;tags&quot;] = &quot;finance,2024&quot;
};

var result = await curl.UploadFileAsync(
    &quot;https://api.example.com/documents&quot;,
    &quot;/path/to/report.pdf&quot;,
    &quot;document&quot;,
    additionalData
);
</code></pre>
<h3>Multiple File Upload</h3>
<pre><code class="language-csharp">public async Task UploadMultipleFiles(List&lt;string&gt; filePaths)
{
    var curl = new Curl();
    var formData = new MultipartFormDataContent();

    foreach (var filePath in filePaths)
    {
        var fileBytes = File.ReadAllBytes(filePath);
        var fileName = Path.GetFileName(filePath);

        var byteContent = new ByteArrayContent(fileBytes);
        byteContent.Headers.ContentType = MediaTypeHeaderValue.Parse(&quot;application/octet-stream&quot;);

        formData.Add(byteContent, &quot;files&quot;, fileName);
    }

    // Add other form fields
    formData.Add(new StringContent(&quot;batch-upload&quot;), &quot;upload-type&quot;);

    var result = await curl.PostAsync(&quot;https://api.example.com/batch-upload&quot;, formData);
}
</code></pre>
<h2>Working with Streams</h2>
<h3>Streaming Download</h3>
<pre><code class="language-csharp">public async Task StreamDownload(string url, string outputPath)
{
    var curl = new Curl();

    using var response = await curl.GetStreamAsync(url);
    using var fileStream = File.Create(outputPath);

    // Copy in chunks to avoid loading entire file in memory
    var buffer = new byte[8192];
    int bytesRead;
    long totalBytes = 0;

    while ((bytesRead = await response.ReadAsync(buffer, 0, buffer.Length)) &gt; 0)
    {
        await fileStream.WriteAsync(buffer, 0, bytesRead);
        totalBytes += bytesRead;

        Console.Write($&quot;\rDownloaded: {totalBytes:N0} bytes&quot;);
    }

    Console.WriteLine(&quot;\nDownload complete!&quot;);
}
</code></pre>
<h3>Streaming Upload</h3>
<pre><code class="language-csharp">public async Task StreamUpload(string filePath, string url)
{
    using var fileStream = File.OpenRead(filePath);
    var fileInfo = new FileInfo(filePath);

    var curl = new Curl();
    curl.Headers.Add(&quot;Content-Length&quot;, fileInfo.Length.ToString());
    curl.Headers.Add(&quot;Content-Type&quot;, &quot;application/octet-stream&quot;);

    var streamContent = new StreamContent(fileStream);
    var result = await curl.PostAsync(url, streamContent);

    if (result.IsSuccess)
    {
        Console.WriteLine(&quot;Stream upload successful!&quot;);
    }
}
</code></pre>
<h2>File Type Detection</h2>
<h3>Content-Type Detection</h3>
<pre><code class="language-csharp">public string GetContentType(string fileName)
{
    var extension = Path.GetExtension(fileName).ToLowerInvariant();

    return extension switch
    {
        &quot;.pdf&quot; =&gt; &quot;application/pdf&quot;,
        &quot;.jpg&quot; or &quot;.jpeg&quot; =&gt; &quot;image/jpeg&quot;,
        &quot;.png&quot; =&gt; &quot;image/png&quot;,
        &quot;.gif&quot; =&gt; &quot;image/gif&quot;,
        &quot;.txt&quot; =&gt; &quot;text/plain&quot;,
        &quot;.html&quot; =&gt; &quot;text/html&quot;,
        &quot;.json&quot; =&gt; &quot;application/json&quot;,
        &quot;.xml&quot; =&gt; &quot;application/xml&quot;,
        &quot;.zip&quot; =&gt; &quot;application/zip&quot;,
        &quot;.doc&quot; =&gt; &quot;application/msword&quot;,
        &quot;.docx&quot; =&gt; &quot;application/vnd.openxmlformats-officedocument.wordprocessingml.document&quot;,
        &quot;.xls&quot; =&gt; &quot;application/vnd.ms-excel&quot;,
        &quot;.xlsx&quot; =&gt; &quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&quot;,
        _ =&gt; &quot;application/octet-stream&quot;
    };
}

// Use in upload
var contentType = GetContentType(filePath);
curl.Headers.Add(&quot;Content-Type&quot;, contentType);
</code></pre>
<h2>Resume Downloads</h2>
<h3>Partial Content / Range Requests</h3>
<pre><code class="language-csharp">public async Task ResumeDownload(string url, string filePath)
{
    var curl = new Curl();
    long existingLength = 0;

    // Check if partial file exists
    if (File.Exists(filePath))
    {
        var fileInfo = new FileInfo(filePath);
        existingLength = fileInfo.Length;

        // Request remaining bytes
        curl.Headers.Add(&quot;Range&quot;, $&quot;bytes={existingLength}-&quot;);
    }

    var result = await curl.GetAsync(url);

    if (result.StatusCode == HttpStatusCode.PartialContent ||
        result.StatusCode == HttpStatusCode.OK)
    {
        // Append to existing file or create new
        using var fileStream = new FileStream(
            filePath,
            existingLength &gt; 0 ? FileMode.Append : FileMode.Create
        );

        var bytes = Encoding.UTF8.GetBytes(result.Data);
        await fileStream.WriteAsync(bytes, 0, bytes.Length);

        Console.WriteLine(&quot;Download completed!&quot;);
    }
    else if (result.StatusCode == HttpStatusCode.RequestedRangeNotSatisfiable)
    {
        Console.WriteLine(&quot;File already complete!&quot;);
    }
}
</code></pre>
<h2>Binary Data Handling</h2>
<h3>Working with Images</h3>
<pre><code class="language-csharp">public async Task&lt;byte[]&gt; ResizeImage(string imageUrl, int maxWidth, int maxHeight)
{
    var curl = new Curl();
    var imageBytes = await curl.GetBytesAsync(imageUrl);

    using var inputStream = new MemoryStream(imageBytes);
    using var image = Image.FromStream(inputStream);

    // Calculate new dimensions
    var ratioX = (double)maxWidth / image.Width;
    var ratioY = (double)maxHeight / image.Height;
    var ratio = Math.Min(ratioX, ratioY);

    var newWidth = (int)(image.Width * ratio);
    var newHeight = (int)(image.Height * ratio);

    // Resize image
    using var resized = new Bitmap(newWidth, newHeight);
    using var graphics = Graphics.FromImage(resized);
    graphics.DrawImage(image, 0, 0, newWidth, newHeight);

    // Convert back to bytes
    using var outputStream = new MemoryStream();
    resized.Save(outputStream, ImageFormat.Jpeg);
    return outputStream.ToArray();
}
</code></pre>
<h3>Working with ZIP Files</h3>
<pre><code class="language-csharp">public async Task DownloadAndExtractZip(string zipUrl, string extractPath)
{
    var curl = new Curl();

    // Download ZIP to memory
    var zipBytes = await curl.GetBytesAsync(zipUrl);

    // Extract from memory stream
    using var zipStream = new MemoryStream(zipBytes);
    using var archive = new ZipArchive(zipStream, ZipArchiveMode.Read);

    Directory.CreateDirectory(extractPath);

    foreach (var entry in archive.Entries)
    {
        var destinationPath = Path.Combine(extractPath, entry.FullName);

        // Create directory if needed
        var directory = Path.GetDirectoryName(destinationPath);
        if (!string.IsNullOrEmpty(directory))
        {
            Directory.CreateDirectory(directory);
        }

        // Extract file
        if (!string.IsNullOrEmpty(entry.Name))
        {
            entry.ExtractToFile(destinationPath, overwrite: true);
            Console.WriteLine($&quot;Extracted: {entry.FullName}&quot;);
        }
    }
}
</code></pre>
<h2>Large File Handling</h2>
<h3>Chunked Upload</h3>
<pre><code class="language-csharp">public async Task UploadLargeFile(string filePath, string uploadUrl)
{
    const int chunkSize = 1024 * 1024 * 5; // 5MB chunks
    var fileInfo = new FileInfo(filePath);
    var totalChunks = (int)Math.Ceiling((double)fileInfo.Length / chunkSize);

    using var fileStream = File.OpenRead(filePath);
    var buffer = new byte[chunkSize];

    for (int i = 0; i &lt; totalChunks; i++)
    {
        var bytesRead = await fileStream.ReadAsync(buffer, 0, chunkSize);
        var chunk = new byte[bytesRead];
        Array.Copy(buffer, chunk, bytesRead);

        var curl = new Curl();
        curl.Headers.Add(&quot;X-Chunk-Number&quot;, i.ToString());
        curl.Headers.Add(&quot;X-Total-Chunks&quot;, totalChunks.ToString());
        curl.Headers.Add(&quot;X-File-Name&quot;, Path.GetFileName(filePath));

        var result = await curl.PostAsync(
            $&quot;{uploadUrl}/chunk&quot;,
            chunk,
            &quot;application/octet-stream&quot;
        );

        if (!result.IsSuccess)
        {
            throw new Exception($&quot;Failed to upload chunk {i}: {result.Error}&quot;);
        }

        var progress = ((i + 1) * 100.0) / totalChunks;
        Console.Write($&quot;\rUploading: {progress:F1}%&quot;);
    }

    Console.WriteLine(&quot;\nUpload complete!&quot;);
}
</code></pre>
<h2>File Validation</h2>
<h3>Checksum Verification</h3>
<pre><code class="language-csharp">public async Task&lt;bool&gt; DownloadWithVerification(string url, string filePath, string expectedMd5)
{
    var curl = new Curl();

    // Download file
    var fileBytes = await curl.GetBytesAsync(url);

    // Calculate MD5
    using var md5 = MD5.Create();
    var hashBytes = md5.ComputeHash(fileBytes);
    var actualMd5 = BitConverter.ToString(hashBytes).Replace(&quot;-&quot;, &quot;&quot;).ToLowerInvariant();

    if (actualMd5 == expectedMd5.ToLowerInvariant())
    {
        File.WriteAllBytes(filePath, fileBytes);
        Console.WriteLine(&quot;File verified and saved!&quot;);
        return true;
    }
    else
    {
        Console.WriteLine($&quot;Checksum mismatch! Expected: {expectedMd5}, Got: {actualMd5}&quot;);
        return false;
    }
}
</code></pre>
<h2>Temporary Files</h2>
<h3>Safe Temporary File Handling</h3>
<pre><code class="language-csharp">public async Task ProcessTemporaryDownload(string url)
{
    string tempFile = null;

    try
    {
        // Create unique temp file
        tempFile = Path.GetTempFileName();

        var curl = new Curl();
        await curl.DownloadFileAsync(url, tempFile);

        // Process the file
        var content = File.ReadAllText(tempFile);
        Console.WriteLine($&quot;File contains {content.Length} characters&quot;);

        // Do something with the content...
    }
    finally
    {
        // Always clean up temp file
        if (tempFile != null &amp;&amp; File.Exists(tempFile))
        {
            File.Delete(tempFile);
        }
    }
}
</code></pre>
<h2>Error Handling for File Operations</h2>
<h3>Robust Download with Retry</h3>
<pre><code class="language-csharp">public async Task&lt;bool&gt; RobustDownload(string url, string filePath, int maxRetries = 3)
{
    var curl = new Curl();

    for (int attempt = 0; attempt &lt; maxRetries; attempt++)
    {
        try
        {
            Console.WriteLine($&quot;Download attempt {attempt + 1}...&quot;);

            var result = await curl.GetBytesAsync(url);

            // Verify download succeeded
            if (result != null &amp;&amp; result.Length &gt; 0)
            {
                File.WriteAllBytes(filePath, result);
                Console.WriteLine(&quot;Download successful!&quot;);
                return true;
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($&quot;Attempt {attempt + 1} failed: {ex.Message}&quot;);

            if (attempt &lt; maxRetries - 1)
            {
                // Wait before retry with exponential backoff
                await Task.Delay(TimeSpan.FromSeconds(Math.Pow(2, attempt)));
            }
        }
    }

    Console.WriteLine(&quot;Download failed after all retries&quot;);
    return false;
}
</code></pre>
<h2>Best Practices</h2>
<ol>
<li><strong>Use streams for large files</strong> - Avoid loading entire file in memory</li>
<li><strong>Implement progress tracking</strong> - Show download/upload progress</li>
<li><strong>Verify file integrity</strong> - Use checksums when available</li>
<li><strong>Handle partial downloads</strong> - Support resume for large files</li>
<li><strong>Clean up temp files</strong> - Always delete temporary files</li>
<li><strong>Set appropriate timeouts</strong> - Large files need longer timeouts</li>
<li><strong>Validate file types</strong> - Check extensions and content types</li>
<li><strong>Use chunking for huge files</strong> - Split uploads/downloads</li>
<li><strong>Handle errors gracefully</strong> - Retry on network failures</li>
<li><strong>Respect rate limits</strong> - Don&#39;t overwhelm servers</li>
</ol>
<h2>Summary</h2>
<p>File operations with CurlDotNet:</p>
<ul>
<li>Simple methods for common download/upload scenarios</li>
<li>Stream support for large files</li>
<li>Progress tracking capabilities</li>
<li>Resume support for interrupted transfers</li>
<li>Binary data handling for various file types</li>
</ul>
<h2>What&#39;s Next?</h2>
<p>Learn about <a href="11-forms-and-data.html">working with forms and data</a> in the next tutorial.</p>
<hr>
<p><a href="09-authentication-basics.html">‚Üê Previous: Authentication Basics</a> | <a href="11-forms-and-data.html">Next: Forms and Data ‚Üí</a></p>


        </article>
    </main>

    <footer class="site-footer">
        <div class="footer-links">
            <a href="/">üìö Documentation Home</a>
            <a href="https://github.com/jacob-mellor/curl-dot-net">‚≠ê GitHub Repository</a>
            <a href="https://www.nuget.org/packages/CurlDotNet/">üì¶ NuGet Package</a>
        </div>
        <div class="sponsor-info">
            <p>üíé Proudly sponsored by <a href="https://ironsoftware.com">IronSoftware</a></p>
        </div>
        <div class="author-info">
            <p>Written by <a href="https://ironsoftware.com/about-us/authors/jacobmellor/">Jacob Mellor</a>, CTO at IronSoftware</p>
        </div>
        <p style="margin-top: 15px; font-size: 0.85em; opacity: 0.7;">
            ¬© 2024-2025 Jacob Mellor and IronSoftware. All rights reserved.
        </p>
    </footer>
</body>
</html>