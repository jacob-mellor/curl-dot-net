<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tutorial 14: Debugging Requests | CurlDotNet Documentation</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.2.0/github-markdown.min.css">
    <style>
        body { max-width: 980px; margin: 0 auto; padding: 20px; }
        .markdown-body { box-sizing: border-box; min-width: 200px; max-width: 980px; margin: 0 auto; padding: 45px; }
        @media (max-width: 767px) { .markdown-body { padding: 15px; } }
        a { color: #0366d6; }
        pre { background: #f6f8fa; padding: 16px; overflow: auto; }

        /* Breadcrumb styles */
        .breadcrumb-nav {
            background: #f6f8fa;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            padding: 12px 16px;
            margin-bottom: 24px;
            font-size: 14px;
        }
        .breadcrumb-nav a {
            color: #0366d6;
            text-decoration: none;
        }
        .breadcrumb-nav a:hover {
            text-decoration: underline;
        }
        .breadcrumb-nav .separator {
            color: #6a737d;
            margin: 0 8px;
        }

        /* Footer nav styles */
        .footer-nav {
            border-top: 1px solid #e1e4e8;
            margin-top: 32px;
            padding-top: 16px;
            font-size: 14px;
        }
        .footer-nav a {
            color: #0366d6;
            text-decoration: none;
            margin-right: 16px;
        }
        .footer-nav a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body class="markdown-body">
<nav class="breadcrumb-nav">
<a href="/">Documentation Home</a> <span class="separator">›</span> <a href="/tutorials/">Tutorials</a>
</nav>
<h1>Tutorial 14: Debugging Requests</h1>
<p>Learn how to troubleshoot HTTP requests, diagnose issues, and use debugging tools effectively with CurlDotNet.</p>
<h2>Enabling Debug Output</h2>
<h3>Basic Debug Logging</h3>
<pre><code class="language-csharp">public class DebugCurl : Curl
{
    public bool DebugMode { get; set; } = true;

    public override async Task&lt;CurlResult&gt; GetAsync(string url, CancellationToken ct = default)
    {
        if (DebugMode)
        {
            Console.WriteLine($&quot;[DEBUG] GET {url}&quot;);
            Console.WriteLine($&quot;[DEBUG] Headers: {string.Join(&quot;, &quot;, Headers.Select(h =&gt; $&quot;{h.Key}={h.Value}&quot;))}&quot;);
        }

        var stopwatch = Stopwatch.StartNew();
        var result = await base.GetAsync(url, ct);
        stopwatch.Stop();

        if (DebugMode)
        {
            Console.WriteLine($&quot;[DEBUG] Status: {result.StatusCode}&quot;);
            Console.WriteLine($&quot;[DEBUG] Time: {stopwatch.ElapsedMilliseconds}ms&quot;);
            Console.WriteLine($&quot;[DEBUG] Response size: {result.Data?.Length ?? 0} bytes&quot;);

            if (!result.IsSuccess)
            {
                Console.WriteLine($&quot;[DEBUG] Error: {result.Error}&quot;);
            }
        }

        return result;
    }
}
</code></pre>
<h3>Verbose Curl Output</h3>
<pre><code class="language-csharp">public class VerboseCurl : Curl
{
    public VerboseCurl()
    {
        // Enable curl&#39;s verbose output
        Options.Verbose = true;

        // Capture debug information
        OnDebugMessage = message =&gt;
        {
            Console.WriteLine($&quot;[CURL] {message}&quot;);
        };
    }

    public async Task&lt;CurlResult&gt; GetWithFullDebug(string url)
    {
        Console.WriteLine(&quot;=== REQUEST DEBUG INFO ===&quot;);
        Console.WriteLine($&quot;URL: {url}&quot;);
        Console.WriteLine($&quot;Method: GET&quot;);
        Console.WriteLine($&quot;Timeout: {Timeout}&quot;);
        Console.WriteLine(&quot;\nRequest Headers:&quot;);

        foreach (var header in Headers)
        {
            Console.WriteLine($&quot;  {header.Key}: {header.Value}&quot;);
        }

        var result = await GetAsync(url);

        Console.WriteLine(&quot;\n=== RESPONSE DEBUG INFO ===&quot;);
        Console.WriteLine($&quot;Status Code: {result.StatusCode}&quot;);
        Console.WriteLine($&quot;Success: {result.IsSuccess}&quot;);

        if (result.Headers != null)
        {
            Console.WriteLine(&quot;\nResponse Headers:&quot;);
            foreach (var header in result.Headers)
            {
                Console.WriteLine($&quot;  {header.Key}: {header.Value}&quot;);
            }
        }

        if (!string.IsNullOrEmpty(result.Error))
        {
            Console.WriteLine($&quot;\nError: {result.Error}&quot;);
        }

        if (!string.IsNullOrEmpty(result.Data))
        {
            Console.WriteLine($&quot;\nResponse Body (first 500 chars):&quot;);
            Console.WriteLine(result.Data.Substring(0, Math.Min(500, result.Data.Length)));
        }

        return result;
    }
}
</code></pre>
<h2>Request/Response Inspection</h2>
<h3>HTTP Traffic Logger</h3>
<pre><code class="language-csharp">public class HttpTrafficLogger
{
    private readonly string _logPath;
    private readonly Curl _curl;

    public HttpTrafficLogger(string logPath = &quot;http_traffic.log&quot;)
    {
        _logPath = logPath;
        _curl = new Curl();
    }

    public async Task&lt;CurlResult&gt; LoggedRequest(string url, HttpMethod method, string body = null)
    {
        var requestId = Guid.NewGuid().ToString(&quot;N&quot;).Substring(0, 8);
        var timestamp = DateTime.UtcNow;

        // Log request
        await LogRequest(requestId, timestamp, url, method, body);

        // Execute request
        var stopwatch = Stopwatch.StartNew();
        CurlResult result;

        switch (method.Method)
        {
            case &quot;GET&quot;:
                result = await _curl.GetAsync(url);
                break;
            case &quot;POST&quot;:
                result = await _curl.PostAsync(url, body);
                break;
            default:
                throw new NotSupportedException($&quot;Method {method} not supported&quot;);
        }

        stopwatch.Stop();

        // Log response
        await LogResponse(requestId, result, stopwatch.ElapsedMilliseconds);

        return result;
    }

    private async Task LogRequest(string requestId, DateTime timestamp, string url, HttpMethod method, string body)
    {
        var log = new StringBuilder();
        log.AppendLine($&quot;=== REQUEST {requestId} at {timestamp:yyyy-MM-dd HH:mm:ss.fff} ===&quot;);
        log.AppendLine($&quot;{method} {url}&quot;);

        foreach (var header in _curl.Headers)
        {
            log.AppendLine($&quot;{header.Key}: {header.Value}&quot;);
        }

        if (!string.IsNullOrEmpty(body))
        {
            log.AppendLine();
            log.AppendLine(body);
        }

        log.AppendLine();

        await File.AppendAllTextAsync(_logPath, log.ToString());
    }

    private async Task LogResponse(string requestId, CurlResult result, long elapsedMs)
    {
        var log = new StringBuilder();
        log.AppendLine($&quot;=== RESPONSE {requestId} ({elapsedMs}ms) ===&quot;);
        log.AppendLine($&quot;Status: {result.StatusCode}&quot;);

        if (result.Headers != null)
        {
            foreach (var header in result.Headers)
            {
                log.AppendLine($&quot;{header.Key}: {header.Value}&quot;);
            }
        }

        if (!string.IsNullOrEmpty(result.Data))
        {
            log.AppendLine();
            log.AppendLine(result.Data);
        }

        if (!string.IsNullOrEmpty(result.Error))
        {
            log.AppendLine($&quot;ERROR: {result.Error}&quot;);
        }

        log.AppendLine();
        log.AppendLine();

        await File.AppendAllTextAsync(_logPath, log.ToString());
    }
}
</code></pre>
<h2>Network Diagnostics</h2>
<h3>Connection Testing</h3>
<pre><code class="language-csharp">public class NetworkDiagnostics
{
    private readonly Curl _curl = new Curl();

    public async Task&lt;DiagnosticReport&gt; RunDiagnostics(string url)
    {
        var report = new DiagnosticReport { Url = url };

        // Test DNS resolution
        report.DnsTest = await TestDns(url);

        // Test connection
        report.ConnectionTest = await TestConnection(url);

        // Test SSL/TLS
        if (url.StartsWith(&quot;https&quot;))
        {
            report.SslTest = await TestSsl(url);
        }

        // Test response time
        report.ResponseTimeTest = await TestResponseTime(url);

        // Test different methods
        report.MethodTests = await TestMethods(url);

        return report;
    }

    private async Task&lt;TestResult&gt; TestDns(string url)
    {
        try
        {
            var uri = new Uri(url);
            var addresses = await Dns.GetHostAddressesAsync(uri.Host);

            return new TestResult
            {
                Success = true,
                Message = $&quot;Resolved to {addresses.Length} IP addresses&quot;,
                Details = string.Join(&quot;, &quot;, addresses.Select(a =&gt; a.ToString()))
            };
        }
        catch (Exception ex)
        {
            return new TestResult
            {
                Success = false,
                Message = &quot;DNS resolution failed&quot;,
                Error = ex.Message
            };
        }
    }

    private async Task&lt;TestResult&gt; TestConnection(string url)
    {
        var result = await _curl.GetAsync(url);

        return new TestResult
        {
            Success = result.IsSuccess,
            Message = result.IsSuccess ? &quot;Connection successful&quot; : &quot;Connection failed&quot;,
            Error = result.Error,
            StatusCode = result.StatusCode
        };
    }

    private async Task&lt;TestResult&gt; TestSsl(string url)
    {
        try
        {
            var curl = new Curl { Options = { VerifySsl = true } };
            var result = await curl.GetAsync(url);

            return new TestResult
            {
                Success = result.IsSuccess,
                Message = &quot;SSL/TLS verification passed&quot;,
                Details = &quot;Certificate is valid and trusted&quot;
            };
        }
        catch (Exception ex)
        {
            return new TestResult
            {
                Success = false,
                Message = &quot;SSL/TLS verification failed&quot;,
                Error = ex.Message
            };
        }
    }

    private async Task&lt;ResponseTimeTest&gt; TestResponseTime(string url)
    {
        var times = new List&lt;long&gt;();

        for (int i = 0; i &lt; 5; i++)
        {
            var sw = Stopwatch.StartNew();
            await _curl.GetAsync(url);
            sw.Stop();
            times.Add(sw.ElapsedMilliseconds);
        }

        return new ResponseTimeTest
        {
            Success = true,
            AverageMs = times.Average(),
            MinMs = times.Min(),
            MaxMs = times.Max(),
            Samples = times
        };
    }

    private async Task&lt;Dictionary&lt;string, TestResult&gt;&gt; TestMethods(string url)
    {
        var results = new Dictionary&lt;string, TestResult&gt;();

        // Test GET
        var getResult = await _curl.GetAsync(url);
        results[&quot;GET&quot;] = new TestResult
        {
            Success = getResult.IsSuccess,
            StatusCode = getResult.StatusCode
        };

        // Test HEAD
        var headResult = await _curl.HeadAsync(url);
        results[&quot;HEAD&quot;] = new TestResult
        {
            Success = headResult.IsSuccess,
            StatusCode = headResult.StatusCode
        };

        // Test OPTIONS
        var optionsResult = await _curl.OptionsAsync(url);
        results[&quot;OPTIONS&quot;] = new TestResult
        {
            Success = optionsResult.IsSuccess,
            StatusCode = optionsResult.StatusCode,
            Details = optionsResult.Headers?.GetValueOrDefault(&quot;Allow&quot;)
        };

        return results;
    }
}

public class DiagnosticReport
{
    public string Url { get; set; }
    public TestResult DnsTest { get; set; }
    public TestResult ConnectionTest { get; set; }
    public TestResult SslTest { get; set; }
    public ResponseTimeTest ResponseTimeTest { get; set; }
    public Dictionary&lt;string, TestResult&gt; MethodTests { get; set; }

    public void PrintReport()
    {
        Console.WriteLine($&quot;\n=== DIAGNOSTIC REPORT FOR {Url} ===\n&quot;);

        Console.WriteLine($&quot;DNS Resolution: {(DnsTest.Success ? &quot;✓&quot; : &quot;✗&quot;)} {DnsTest.Message}&quot;);
        if (!string.IsNullOrEmpty(DnsTest.Details))
            Console.WriteLine($&quot;  {DnsTest.Details}&quot;);

        Console.WriteLine($&quot;Connection: {(ConnectionTest.Success ? &quot;✓&quot; : &quot;✗&quot;)} {ConnectionTest.Message}&quot;);

        if (SslTest != null)
            Console.WriteLine($&quot;SSL/TLS: {(SslTest.Success ? &quot;✓&quot; : &quot;✗&quot;)} {SslTest.Message}&quot;);

        Console.WriteLine($&quot;\nResponse Times:&quot;);
        Console.WriteLine($&quot;  Average: {ResponseTimeTest.AverageMs:F0}ms&quot;);
        Console.WriteLine($&quot;  Min: {ResponseTimeTest.MinMs}ms, Max: {ResponseTimeTest.MaxMs}ms&quot;);

        Console.WriteLine($&quot;\nMethod Support:&quot;);
        foreach (var method in MethodTests)
        {
            Console.WriteLine($&quot;  {method.Key}: {(method.Value.Success ? &quot;✓&quot; : &quot;✗&quot;)} (HTTP {method.Value.StatusCode})&quot;);
        }
    }
}

public class TestResult
{
    public bool Success { get; set; }
    public string Message { get; set; }
    public string Error { get; set; }
    public string Details { get; set; }
    public HttpStatusCode StatusCode { get; set; }
}

public class ResponseTimeTest : TestResult
{
    public double AverageMs { get; set; }
    public long MinMs { get; set; }
    public long MaxMs { get; set; }
    public List&lt;long&gt; Samples { get; set; }
}
</code></pre>
<h2>Common Issues and Solutions</h2>
<h3>Debugging Timeout Issues</h3>
<pre><code class="language-csharp">public class TimeoutDebugger
{
    public async Task DebugTimeouts(string url)
    {
        Console.WriteLine($&quot;Testing timeouts for {url}\n&quot;);

        // Test with different timeout values
        var timeouts = new[] { 1, 5, 10, 30, 60 };

        foreach (var timeout in timeouts)
        {
            var curl = new Curl { Timeout = TimeSpan.FromSeconds(timeout) };
            var sw = Stopwatch.StartNew();

            try
            {
                var result = await curl.GetAsync(url);
                sw.Stop();

                if (result.IsSuccess)
                {
                    Console.WriteLine($&quot;✓ {timeout}s timeout: Success in {sw.ElapsedMilliseconds}ms&quot;);
                    break;
                }
                else
                {
                    Console.WriteLine($&quot;✗ {timeout}s timeout: Failed - {result.Error}&quot;);
                }
            }
            catch (OperationCanceledException)
            {
                sw.Stop();
                Console.WriteLine($&quot;✗ {timeout}s timeout: Timed out after {sw.ElapsedMilliseconds}ms&quot;);
            }
        }
    }
}
</code></pre>
<h3>Debugging Authentication Issues</h3>
<pre><code class="language-csharp">public class AuthDebugger
{
    public async Task DebugAuth(string url, string token)
    {
        var curl = new Curl();

        Console.WriteLine(&quot;=== AUTHENTICATION DEBUG ===\n&quot;);

        // Test without auth
        Console.WriteLine(&quot;1. Testing without authentication:&quot;);
        var noAuthResult = await curl.GetAsync(url);
        Console.WriteLine($&quot;   Status: {noAuthResult.StatusCode}&quot;);
        if (noAuthResult.StatusCode == HttpStatusCode.Unauthorized)
        {
            Console.WriteLine(&quot;   ✓ Server correctly requires authentication&quot;);
        }

        // Test with auth
        Console.WriteLine(&quot;\n2. Testing with Bearer token:&quot;);
        curl.Headers[&quot;Authorization&quot;] = $&quot;Bearer {token}&quot;;
        var authResult = await curl.GetAsync(url);
        Console.WriteLine($&quot;   Status: {authResult.StatusCode}&quot;);

        if (authResult.IsSuccess)
        {
            Console.WriteLine(&quot;   ✓ Authentication successful&quot;);
        }
        else if (authResult.StatusCode == HttpStatusCode.Unauthorized)
        {
            Console.WriteLine(&quot;   ✗ Token rejected - may be expired or invalid&quot;);

            // Try to decode JWT to check expiration
            try
            {
                var parts = token.Split(&#39;.&#39;);
                if (parts.Length == 3)
                {
                    var payload = Encoding.UTF8.GetString(
                        Convert.FromBase64String(parts[1] + &quot;==&quot;)
                    );
                    Console.WriteLine($&quot;   Token payload: {payload}&quot;);
                }
            }
            catch
            {
                Console.WriteLine(&quot;   Could not decode token&quot;);
            }
        }
        else if (authResult.StatusCode == HttpStatusCode.Forbidden)
        {
            Console.WriteLine(&quot;   ✗ Authenticated but not authorized for this resource&quot;);
        }
    }
}
</code></pre>
<h3>Debugging JSON Issues</h3>
<pre><code class="language-csharp">public class JsonDebugger
{
    public async Task DebugJsonResponse(string url)
    {
        var curl = new Curl();
        var result = await curl.GetAsync(url);

        Console.WriteLine(&quot;=== JSON DEBUG ===\n&quot;);

        if (!result.IsSuccess)
        {
            Console.WriteLine($&quot;Request failed: {result.Error}&quot;);
            return;
        }

        // Check Content-Type
        if (result.Headers.TryGetValue(&quot;Content-Type&quot;, out var contentType))
        {
            Console.WriteLine($&quot;Content-Type: {contentType}&quot;);

            if (!contentType.Contains(&quot;json&quot;))
            {
                Console.WriteLine(&quot;⚠ Warning: Content-Type is not JSON&quot;);
            }
        }

        // Try to parse as JSON
        try
        {
            using var doc = JsonDocument.Parse(result.Data);
            Console.WriteLine(&quot;✓ Valid JSON structure&quot;);

            // Pretty print
            var options = new JsonSerializerOptions { WriteIndented = true };
            var prettyJson = JsonSerializer.Serialize(doc.RootElement, options);
            Console.WriteLine(&quot;\nFormatted JSON:&quot;);
            Console.WriteLine(prettyJson);
        }
        catch (JsonException ex)
        {
            Console.WriteLine($&quot;✗ Invalid JSON: {ex.Message}&quot;);
            Console.WriteLine(&quot;\nRaw response (first 1000 chars):&quot;);
            Console.WriteLine(result.Data.Substring(0, Math.Min(1000, result.Data.Length)));
        }
    }
}
</code></pre>
<h2>Performance Profiling</h2>
<h3>Request Performance Profiler</h3>
<pre><code class="language-csharp">public class PerformanceProfiler
{
    private readonly Curl _curl = new Curl();

    public async Task&lt;PerformanceProfile&gt; ProfileRequest(string url)
    {
        var profile = new PerformanceProfile { Url = url };

        // DNS lookup time
        var dnsStart = Stopwatch.StartNew();
        var addresses = await Dns.GetHostAddressesAsync(new Uri(url).Host);
        profile.DnsLookupMs = dnsStart.ElapsedMilliseconds;

        // Connection time (approximate)
        var connectStart = Stopwatch.StartNew();
        var tcpClient = new TcpClient();
        try
        {
            await tcpClient.ConnectAsync(new Uri(url).Host, new Uri(url).Port);
            profile.ConnectionMs = connectStart.ElapsedMilliseconds;
            tcpClient.Close();
        }
        catch { }

        // Full request time
        var requestStart = Stopwatch.StartNew();
        var result = await _curl.GetAsync(url);
        profile.TotalMs = requestStart.ElapsedMilliseconds;

        // Response size
        profile.ResponseBytes = result.Data?.Length ?? 0;

        // Calculate derived metrics
        profile.TransferMs = profile.TotalMs - profile.ConnectionMs;
        profile.TransferRateMBps = profile.ResponseBytes / 1024.0 / 1024.0 / (profile.TransferMs / 1000.0);

        return profile;
    }
}

public class PerformanceProfile
{
    public string Url { get; set; }
    public long DnsLookupMs { get; set; }
    public long ConnectionMs { get; set; }
    public long TransferMs { get; set; }
    public long TotalMs { get; set; }
    public int ResponseBytes { get; set; }
    public double TransferRateMBps { get; set; }

    public void Print()
    {
        Console.WriteLine($&quot;\n=== PERFORMANCE PROFILE ===&quot;);
        Console.WriteLine($&quot;URL: {Url}&quot;);
        Console.WriteLine($&quot;DNS Lookup: {DnsLookupMs}ms&quot;);
        Console.WriteLine($&quot;Connection: {ConnectionMs}ms&quot;);
        Console.WriteLine($&quot;Transfer: {TransferMs}ms&quot;);
        Console.WriteLine($&quot;Total: {TotalMs}ms&quot;);
        Console.WriteLine($&quot;Response Size: {ResponseBytes:N0} bytes&quot;);
        Console.WriteLine($&quot;Transfer Rate: {TransferRateMBps:F2} MB/s&quot;);
    }
}
</code></pre>
<h2>Integration with Debugging Tools</h2>
<h3>Fiddler/Charles Proxy Integration</h3>
<pre><code class="language-csharp">public class ProxyDebugCurl : Curl
{
    public ProxyDebugCurl(bool useDebugProxy = true)
    {
        if (useDebugProxy)
        {
            // Configure to use local debugging proxy
            Options.Proxy = &quot;http://localhost:8888&quot;;

            // Trust the proxy&#39;s certificate (for HTTPS debugging)
            Options.VerifySsl = false;

            Console.WriteLine(&quot;Configured to use debugging proxy at localhost:8888&quot;);
            Console.WriteLine(&quot;Make sure Fiddler or Charles Proxy is running&quot;);
        }
    }
}
</code></pre>
<h2>Best Practices</h2>
<ol>
<li><strong>Enable debug mode in development</strong> - Not in production</li>
<li><strong>Log to files</strong> - Console output can be overwhelming</li>
<li><strong>Include timestamps</strong> - Track when issues occur</li>
<li><strong>Capture full context</strong> - Headers, body, and metadata</li>
<li><strong>Use correlation IDs</strong> - Track requests across systems</li>
<li><strong>Implement structured logging</strong> - Easy to parse and analyze</li>
<li><strong>Test edge cases</strong> - Timeouts, large responses, auth failures</li>
<li><strong>Profile performance</strong> - Identify bottlenecks</li>
<li><strong>Use debugging proxies</strong> - Fiddler, Charles, Wireshark</li>
<li><strong>Keep sensitive data secure</strong> - Don&#39;t log passwords or tokens</li>
</ol>
<h2>Summary</h2>
<p>Effective debugging is crucial for troubleshooting:</p>
<ul>
<li>Enable verbose output for detailed information</li>
<li>Log requests and responses for analysis</li>
<li>Run diagnostics to identify issues</li>
<li>Profile performance to find bottlenecks</li>
<li>Use appropriate tools for different scenarios</li>
</ul>
<h2>Congratulations!</h2>
<p>You&#39;ve completed all 14 tutorials! You now have a comprehensive understanding of CurlDotNet and can:</p>
<ul>
<li>Make various types of HTTP requests</li>
<li>Handle responses and errors properly</li>
<li>Work with different data formats</li>
<li>Implement authentication</li>
<li>Optimize performance with parallel requests</li>
<li>Debug issues effectively</li>
</ul>
<hr>
<p><a href="13-parallel-requests.html">← Previous: Parallel Requests</a> | <a href="README.html">Back to Tutorials</a></p>


<nav class="footer-nav">
<a href="/">← Documentation Home</a> |
<a href="https://github.com/jacob-mellor/curl-dot-net">View on GitHub</a> |
<a href="https://www.nuget.org/packages/CurlDotNet/">NuGet Package</a>
</nav>
</body>
</html>